{
    "result": [
        {
            "content": "A 没有语句结束符\nB 没有语句结束符\nC 正确\nD 语法错误",
            "index": 0
        },
        {
            "content": "形参\n缓冲区指针\n一个内存缓冲区首地址",
            "index": 1
        },
        {
            "content": "展开全部\nwinver---------检查Windows版本\nwmimgmt.msc----打开windows管理体系结构(WMI)\nwupdmgr--------windows更新程序\nwscript--------windows脚本宿主设置\nwrite----------写字板\nwinmsd---------系统信息\nwiaacmgr-------扫描仪和照相机向导\nwinchat--------XP自带局域网聊天\n\nmem.exe--------显示内存使用情况\nMsconfig.exe---系统配置实用程序\nmplayer2-------简易widnows media player\nmspaint--------画图板\nmstsc----------远程桌面连接\nmplayer2-------媒体播放机\nmagnify--------放大镜实用程序\nmmc------------打开控制台\nmobsync--------同步命令\n\ndxdiag---------检查DirectX信息\ndrwtsn32------ 系统医生\ndevmgmt.msc--- 设备管理器\ndfrg.msc-------磁盘碎片整理程序\ndiskmgmt.msc---磁盘管理实用程序\ndcomcnfg-------打开系统组件服务\nddeshare-------打开DDE共享设置\ndvdplay--------DVD播放器\nat/? > 盘符\\文件名 将文件倒入记事本\n\nnet stop messenger-----停止信使服务\nnet start messenger----开始信使服务\nnotepad--------打开记事本\nnslookup-------网络管理的工具向导\nntbackup-------系统备份和还原\nnarrator-------屏幕“讲述人”\nntmsmgr.msc----移动存储管理器\nntmsoprq.msc---移动存储管理员操作请求\nnetstat -an----(TC)命令检查接口\n\nsyncapp--------创建一个公文包\nsysedit--------系统配置编辑器\nsigverif-------文件签名验证程序\nsndrec32-------录音机\nshrpubw--------创建共享文件夹\nsecpol.msc-----本地安全策略\nsyskey---------系统加密，一旦加密就不能解开，保护windows xp系统的双重密码\nservices.msc---本地服务设置\nSndvol32-------音量控制程序\nsfc.exe--------系统文件检查器\nsfc /scannow---windows文件保护\n\ntsshutdn-------60秒倒计时关机命令\ntourstart------xp简介（安装完成后出现的漫游xp程序）\ntaskmgr--------任务管理器\n\neventvwr-------事件查看器\neudcedit-------造字程序\nexplorer-------打开资源管理器\n\npackager-------对象包装程序\nperfmon.msc----计算机性能监测程序\nprogman--------程序管理器\n\nregedit.exe----注册表\nrsop.msc-------组策略结果集\nregedt32-------注册表编辑器\nrononce -p ----15秒关机\nregsvr32 /u *.dll----停止dll文件运行\nregsvr32 /u zipfldr.dll------取消ZIP支持\n\ncmd.exe--------CMD命令提示符\nchkdsk.exe-----Chkdsk磁盘检查\ncertmgr.msc----证书管理实用程序\ncalc-----------启动计算器\ncharmap--------启动字符映射表\ncliconfg-------SQL SERVER 客户端网络实用程序\nClipbrd--------剪贴板查看器\nconf-----------启动netmeeting\ncompmgmt.msc---计算机管理\ncleanmgr-------垃圾整理\nciadv.msc------索引服务程序\n\nosk------------打开屏幕键盘\nodbcad32-------ODBC数据源管理器\noobe/msoobe /a----检查XP是否激活\nlusrmgr.msc----本机用户和组\nlogoff---------注销命令\n\niexpress-------木马捆绑工具，系统自带\n\nNslookup-------IP地址侦测器\n\nfsmgmt.msc-----共享文件夹管理器\n\nutilman--------辅助工具管理器\n\ngpedit.msc-----组策略\n\nrun里面的内容可以定制的\n\n定制你的运行输入框\n在Windows里面，Microsoft提供了一个新的快捷启动程序的方法：运行\n打开[开始]------[运行]，里面可以直接启动一些特定的程序，如：输入notepad.exe启动记事本，输入xdict.exe启动金山词霸等等。\n\n启动的原理是什么呢？很简单，在注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths下面，可以看到很多次级主键，每一个次级主键就对应着一个能够在运行里面输入的内容。\n\n以ACDSee.exe主键为例：右边有2个字符串，默认对应的是这个程序的绝对路径，而Path对应的是这个程序所处的目录。\n\n定制的方法很简单：在App Paths下新建一个不同名的次级主键（例如：Smallfrogs.EXE），然后修改右边的默认为你要启动的程序的路径（例如：C:\\Program Files\\My APP\\Smallfrogs.EXE），然后新建一个字符串Path，修改为那个程序所处的目录（例如::C:\\Program Files\\My APP\\）。\n\n然后就可以在运行里面输入：Smallfrogs.EXE来启动C:\\Program Files\\My APP\\Smallfrogs.EXE这个程序了。\n\n注意！系统是靠次级主键的名字来辨认程序的，即使你不使用Smallfrogs.EXE建立次级主键，而使用SSSSS.EXE建立次级主键，如果莫任何Path的内容和上例一样的话，输入SSSSS.EXE启动的程序仍然是C:\\Program Files\\My APP\\Smallfrogs.EXE这个程序。\n\nwupdmgr WIDNOWS UPDATE\nshutdown -a 关机解除\nabout:home 登陆首页\n... (三个半角点) 我的电脑\ndvdplay DVD播放器\nfsmgmt 共享控制台\n桌面 打开桌面所在文件夹\n..（两点）打开C:\\Documents and Settings\n.（一点）打开「开始」菜单\ncalc 计算器\nclipbrd 剪贴板查看器\ncontrol 打开控制面板\neventvwr 事件查看器\nmstsc 远程桌面\n\nWin2000命令全集[帖] -> Windows 2k/2003 Server\naccwiz.exe > Accessibility Wizard for walking you through setting up your machine for your mobility needs. 辅助工具向导\nacsetups.exe > ACS setup DCOM server executable\nactmovie.exe > Direct Show setup tool 直接显示安装工具\nappend.exe > Allows programs to open data in specified directories as if they were in the current directory. 允许程序打开制定目录中的数据\narp.exe > NETWORK Display and modify IP - Hardware addresses 显示和更改计算机的IP与硬件物理地址的对应列表\nat.exe > AT is a scheduling utility also included with UNIX 计划运行任务\natmadm.exe > Displays statistics for ATM call manager. ATM调用管理器统计\nattrib.exe > Display and modify attributes for files and folders 显示和更改文件和文件夹属性\nautochk.exe > Used to check and repair Windows File Systems 检测修复文件系统\nautoconv.exe > Automates the file system conversion during reboots 在启动过程中自动转化系统\nautofmt.exe > Automates the file format process during reboots 在启动过程中格式化进程\nautolfn.exe > Used for formatting long file names 使用长文件名格式\nbootok.exe > Boot acceptance application for registry\nbootvrfy.exe > Bootvrfy.exe, a program included in Windows 2000 that notifies the system that startup was successful. Bootvrfy.exe can be run on a local or remote computer. 通报启动成功\ncacls.exe > Displays or modifies access control lists (ACLs) of files. 显示和编辑ACL\ncalc.exe > Windows Calculators 计算器\ncdplayer.exe > Windows CD Player CD播放器\nchange.exe > Change { User | Port | Logon } 与终端服务器相关的查询\ncharmap.exe > Character Map 字符映\\*表\nchglogon.exe > Same as using \"Change Logon\" 启动或停用会话记录\nchgport.exe > Same as using \"Change Port\" 改变端口（终端服务）\nchgusr.exe > Same as using \"Change User\" 改变用户（终端服务）\nchkdsk.exe > Check the hard disk for errors similar to Scandisk 3 Stages must specify a Drive Letter 磁盘检测程序\nchkntfs.exe > Same as using chkdsk but for NTFS NTFS磁盘检测程序\ncidaemon.exe > Component of Ci Filer Service 组成Ci文档服务\ncipher.exe > Displays or alters the encryption of directories [files] on NTFS partitions. 在NTFS上显示或改变加密的文件或目录\ncisvc.exe > Content Index -- Its the content indexing service for I 索引内容\nckcnv.exe > Cookie Convertor 变换Cookie\ncleanmgr.exe > Disk Cleanup, popular with Windows 98 磁盘清理\ncliconfg.exe > SQL Server Client Network Utility SQL客户网络工具\nclipbrd.exe > Clipboard viewer for Local will allow you to connect to other clipboards 剪贴簿查看器\nclipsrv.exe > Start the clipboard Server 运行Clipboard服务\nclspack.exe > CLSPACK used to create a file listing of system packages 建立系统文件列表清单\ncluster.exe > Display a cluster in a domain 显示域的集群\n_cmd_.exe > Famous command prompt 没什么好说的！\ncmdl32.exe > Connection Manager Auto-Download 自动下载连接管理\ncmmgr32.exe > Connection Manager 连接管理器\ncmmon32.exe > Connection Manager Monitor 连接管理器监视\ncmstp.exe > Connection Manager Profile Manager 连接管理器配置文件安装程序\ncomclust.exe > about cluster server 集群\ncomp.exe > ComClust Add, Remove, or Join a cluster. 比较两个文件和文件集的内容＊\ncompact.exe > Displays or alters the compression of files on NTFS partitions. 显示或改变NTFS分区上文件的压缩状态\nconime.exe > Console IME IME控制台\ncontrol.exe > Starts the control panel 控制面板\nconvert.exe > Convert File System to NTFS 转换文件系统到NTFS\nconvlog.exe > Converts MS IIS log files 转换IIS日志文件格式到NCSA格式\ncprofile.exe > Copy profiles 转换显示模式\ncscript.exe > MS Windows Scripts Host Version 5.1 较本宿主版本\ncsrss.exe > Client Server Runtime Process 客户服务器Runtime进程\ncsvde.exe > Comma Separated Variable Import/Export Utility 日至格式转换程序\ndbgtrace.exe > 和Terminal Server相关\ndcomcnfg.exe > Display the current DCOM configuration. DCOM配置属性\ndcphelp.exe > ?\ndcpromo.exe > Promote a domain controller to ADSI AD安装向导\nddeshare.exe > Display DDE shares on local or remote computer DDE共享\nddmprxy.exe >\ndebug.exe > Runs Debug, a program testing and editing tool. 就是DEBUG啦！\ndfrgfat.exe > Defrag FAT file system FAT分区磁盘碎片整理程序\ndfrgntfs.exe > Defrag NTFS file system NTFS分区磁盘碎片整理程序\ndfs_cmd_.exe > configures a Dfs tree 配置一个DFS树\ndfsinit.exe > Distributed File System Initialization 分布式文件系统初始化\ndfssvc.exe > Distributed File System Server 分布式文件系统服务器\ndiantz.exe > MS Cabinet Maker 制作CAB文件\ndiskperf.exe > Starts physical Disk Performance counters 磁盘性能计数器\ndllhost.exe > dllhost is used on all versions of Windows 2000. dllhost is the hedost process for all COM+ applications. 所有COM+应用软件的主进程\ndllhst3g.exe >\ndmadmin.exe > Disk Manager Service 磁盘管理服务\ndmremote.exe > Part of disk management 磁盘管理服务的一部分\ndns.exe > DNS Applications DNS\ndoskey.exe > recalls Windows command lines and creates macros 命令行创建宏\ndosx.exe > DOS Extender DOS扩展\ndplaysvr.exe > Direct Play Helper 直接运行帮助\ndrwatson.exe > Dr Watson for 2000 Fault Detector 华生医生错误检测\ndrwtsn32.exe > Dr Watson for 2000 viewer and configuration manager 华生医生显示和配置管理\ndtcsetup.exe > Installs MDTC\ndvdplay.exe > Windows 2000 DVD player DVD播放\ndxdiag.exe > Direct-X Diagnostics Direct-X诊断工具\nedlin.exe > line-oriented text editor. 命令行的文本编辑器（历史悠久啊！）\nedlin.exe > line-oriented text editor. 命令行的文本编辑器（历史悠久啊！）\nesentutl.exe > MS Database Utility MS数据库工具\neudcedit.exe > Private character editor Ture Type造字程序\neventvwr.exe > Windows 2000 Event Viewer 事件查看器\nevnt_cmd_.exe > Event to trap translator; Configuration tool\nevntwin.exe > Event to trap translator setup\nexe2bin.exe > Converts EXE to binary format 转换EXE文件到二进制\nexpand.exe > Expand Files that have been compressed 解压缩\nextrac32.exe > CAB File extraction utility 解CAB工具\nfastopen.exe > Fastopen tracks the location of files on a hard disk and stores the information in memory for fast access. 快速访问在内存中的硬盘文件\nfaxcover.exe > Fax Cover page editor 传真封面编辑\nfaxqueue.exe > Display Fax Queue 显示传真队列\nfaxsend.exe > Fax Wizard for sending faxes 发送传真向导\nfaxsvc.exe > Starts fax server 启动传真服务\nfc.exe > Compares two files or sets of files and their differences 比较s两个文件的不同\nfind.exe > Searches for a text string in file or files 查找文件中的文本行\nfindstr.exe > Searches for strings in files 查找文件中的行\nfinger.exe > Fingers a user and displays statistics on that user Finger一个用户并显示出统计结果\nfixmapi.exe > Fix mapi files 修复MAPI文件\nflattemp.exe > Enable or disable temporally directories 允许或者禁用临时文件目录\nfontview.exe > Display fonts in a font file 显示字体文件中的字体\nforcedos.exe > Forces a file to start in dos mode. 强制文件在DOS模式下运行\nfreecell.exe > Popular Windows Game 空当接龙\nftp.exe > File Transfer Protocol used to transfer files over a network connection 就是FTP了\ngdi.exe > Graphic Device Interface 图形界面驱动\ngrovel.exe >\ngrpconv.exe > Program Manager Group Convertor 转换程序管理员组\nhelp.exe > displays help for Windows 2000 commands 显示帮助\nhostname.exe > Display hostname for machine. 显示机器的Hostname\nie4uinit.exe > IE5 User Install tool IE5用户安装工具\nieshwiz.exe > Customize folder wizard 自定义文件夹向导\niexpress.exe > Create and setup packages for install 穿件安装包\niisreset.exe > Restart IIS Admin Service 重启IIS服务\ninternat.exe > Keyboard Language Indicator Applet 键盘语言指示器\nipconfig.exe > Windows 2000 IP configuration. 察看IP配置\nipsecmon.exe > IP Security Monitor IP安全监视器\nipxroute.exe > IPX Routing and Source Routing Control Program IPX路由和源路由控制程序\nirftp.exe > Setup FTP for wireless communication 无线连接\nismserv.exe > Intersite messaging Service 安装或者删除Service Control Manager中的服务\njdbgmgr.exe > Microsoft debugger for java 4 Java4的调试器\njetconv.exe > Convert a Jet Engine Database 转换Jet Engine数据库\njetpack.exe > Compact Jet Database. 压缩Jet数据库\njview.exe > Command-line loader for Java Java的命令行装载者\nkrnl386.exe > Core Component for Windows 2000 2000的核心组件\nlabel.exe > Change label for drives 改变驱动器的卷标\nlcwiz.exe > License Compliance Wizard for local or remote systems. 许可证符合向导\nldifde.exe > LDIF cmd line manager LDIF目录交换命令行管理\nlicmgr.exe > Terminal Server License Manager 终端服务许可协议管理\nlights.exe > display connection status lights 显示连接状况\nllsmgr.exe > Windows 2000 License Manager 2000许可协议管理\nllssrv.exe > Start the license Server 启动许可协议服务器\nlnkstub.exe >\nlocator.exe > RPC Locator 远程定位\nlodctr.exe > Load perfmon counters 调用性能计数\nlogoff.exe > Log current user off. 注销用户\nlpq.exe > Displays status of a remote LPD queue 显示远端的LPD打印队列的状态，显示被送到基于Unix的服务器的打印任务\nlpr.exe > Send a print job to a network printer. 重定向打印任务到网络中的打印机。通常用于Unix客户打印机将打印任务发送给连接了打印设备的NT的打印机服务器。\nlsass.exe > LSA Executable and Server DLL 运行LSA和Server的DLL\nlserver.exe > Specifies the new DNS domain for the default server 指定默认Server新的DNS域\nos2.exe > An OS/2 Warp Server (os2 /o) OS/2\nos2srv.exe > An OS/2 Warp Server OS/2\nos2ss.exe > An OS/2 Warp Server OS/2\nosk.exe > On Screen Keyboard 屏幕键盘\npackager.exe > Windows 2000 Packager Manager 对象包装程序\npathping.exe > Combination of Ping and Tracert 包含Ping和Tracert的程序\npax.exe > is a POSIX program and path names used as arguments must be specified in POSIX format. Use \"//C/Users/Default\" instead of \"C:\\USERS\\DEFAULT.\" 启动便携式存档互换 (Pax) 实用程序\npentnt.exe > Used to check the Pentium for the floating point division error. 检查Pentium的浮点错误\nperfmon.exe > Starts Windows Performance Monitor 性能监视器\nping.exe > Packet Internet Groper 验证与远程计算机的连接\nposix.exe > Used for backward compatibility with Unix 用于兼容Unix\nprint.exe > Cmd line used to print files 打印文本文件或显示打印队列的内容。\nprogman.exe > Program manager 程序管理器\nproquota.exe > Profile quota program\npsxss.exe > POSIX Subsystem Application Posix子系统应用程序\nqappsrv.exe > Displays the available application terminal servers on the network\n在网络上显示终端服务器可用的程序\nqprocess.exe > Display information about processes local or remote 在本地或远程显示进程的信息（需终端服务）\nquery.exe > Query TERMSERVER user process and sessions 查询进程和对话\nquser.exe > Display information about a user logged on 显示用户登陆的信息（需终端服务）\nqwinsta.exe > Display information about Terminal Sessions. 显示终端服务的信息\nrasadmin.exe > Start the remote access admin service 启动远程访问服务\nrasautou.exe > Creates a RAS connection 建立一个RAS连接\nrasdial.exe > Dial a connection 拨号连接\nras.exe > Starts a RAS connection 运行RAS连接\nrcp.exe > Copies a file from and to a RCP service. 在 Windows 2000 计算机和运行远程外壳端口监控程序 rshd 的系统之间复制文件\nrdpclip.exe > RdpClip allows you to copy and paste files between a terminal session and client console session. 再终端和本地复制和粘贴文件\nrecover.exe > Recovers readable information from a bad or defective disk 从坏的或有缺陷的磁盘中恢复可读取的信息。\nredir.exe > Starts the redirector service 运行重定向服务\nregedt32.exe > 32-bit register service 32位注册服务\nregini.exe > modify registry permissions from within a script 用脚本修改注册许可\nregister.exe > Register a program so it can have special execution characteristics. 注册包含特殊运行字符的程序\nregsvc.exe >\nregsvr32.exe > Registers and unregisters dlls. As to how and where it registers them I dont know. 注册和反注册DLL\nregtrace.exe > Options to tune debug options for applications failing to dump trace statements\nTrace 设置\nregwiz.exe > Registration Wizard 注册向导\nremrras.exe >\nreplace.exe > Replace files 用源目录中的同名文件替换目标目录中的文件。\nreset.exe > Reset an active section 重置活动部分\nrexec.exe > Runs commands on remote hosts running the REXEC service. 在运行 REXEC 服务的远程计算机上运行命令。rexec 命令在执行指定命令前，验证远程计算机上的用户名，只有安装了 TCP/IP 协议后才可以使用该命令。\nrisetup.exe > Starts the Remote Installation Service Wizard. 运行远程安装向导服务\nroute.exe > display or edit the current routing tables. 控制网络路由表\nroutemon.exe > no longer supported 不再支持了！\nrouter.exe > Router software that runs either on a dedicated DOS or on an OS/2 system. Route软件在 DOS或者是OS/2系统\nrsh.exe > Runs commands on remote hosts running the RSH service 在运行 RSH 服务的远程计算机上运行命令\nrsm.exe > Mounts and configures remote system media 配置远程系统媒体\nrsnotify.exe > Remote storage notification recall 远程存储通知回显\nrsvp.exe > Resource reservation protocol 源预约协议\nrunas.exe > RUN a program as another user 允许用户用其他权限运行指定的工具和程序\nrundll32.exe > Launches a 32-bit dll program 启动32位DLL程序\nrunonce.exe > Causes a program to run during startup 运行程序再开始菜单中\nrwinsta.exe > Reset the session subsystem hardware and software to known initial values 重置会话子系统硬件和软件到最初的值\nsavedump.exe > Does not write to e:\\winnt\\user.dmp 不写入User.dmp中\nscardsvr.exe > Smart Card resource management server 子能卡资源管理服务器\nschupgr.exe > It will read the schema update files (.ldf files) and upgrade the schema. (part of ADSI) 读取计划更新文件和更新计划\nsecedit.exe > Starts Security Editor help 自动安全性配置管理\nservices.exe > Controls all the services 控制所有服务\nsethc.exe > Set High Contrast - changes colours and display mode Logoff to set it back to normal 设置高对比\nsetreg.exe > Shows the Software Publishing State Key values 显示软件发布的国家语言\nsetup.exe > GUI box prompts you to goto control panel to configure system components 安装程序（转到控制面板）\nsetver.exe > Set Version for Files 设置 MS-DOS 子系统向程序报告的 MS-DOS 版本号\nsfc.exe > System File Checker test and check system files for integrity 系统文件检查\nsfmprint.exe > Print Services for Macintosh 打印Macintosh服务\nsfmpsexe.exe >\nsfmsvc.exe >\nshadow.exe > Monitor another Terminal Services session. 监控另外一台中端服务器会话\nshare.exe > Windows 2000 和 MS-DOS 子系统不使用该命令。接受该命令只是为了与 MS-DOS 文件兼容\nshmgrate.exe >\nshrpubw.exe > Create and Share folders 建立和共享文件夹\nsigverif.exe > File Signature Verification 文件签名验证\nskeys.exe > Serial Keys utility 序列号制作工具\nsmlogsvc.exe > Performance Logs and Alerts 性能日志和警报\nsmss.exe >\nsndrec32.exe > starts the Windows Sound Recorder 录音机\nsndvol32.exe > Display the current volume information 显示声音控制信息\nsnmp.exe > Simple Network Management Protocol used for Network Mangement 简单网络管理协议\nsnmptrap.exe > Utility used with SNMP SNMP工具\nsol.exe > Windows Solitaire Game 纸牌\nsort.exe > Compares files and Folders 读取输入、排序数据并将结果写到屏幕、文件和其他设备上\nSPOOLSV.EXE > Part of the spooler service for printing 打印池服务的一部分\nsprestrt.exe >\nsrvmgr.exe > Starts the Windows Server Manager 服务器管理器\nstimon.exe > WDM StillImage- > Monitor\nstisvc.exe > WDM StillImage- > Service\nsubst.exe > Associates a path with a drive letter 将路径与驱动器盘符关联\nsvchost.exe > Svchost.exe is a generic host process name for services that are run from dynamic-link libraries (DLLs). DLL得主进程\nsyncapp.exe > Creates Windows Briefcase. 创建Windows文件包\nsysedit.exe > Opens Editor for 4 system files 系统配置编辑器\nsyskey.exe > Encrypt and secure system database NT账号数据库按群工具\nsysocmgr.exe > Windows 2000 Setup 2000安装程序\nsystray.exe > Starts the systray in the lower right corner. 在低权限运",
            "index": 2
        },
        {
            "content": "答案：D\n\n对于数组a[10]，a就是该数组的首地址，定义指针p赋值为a，那么a和p的操作基本相同:\na[5]=p[5]=*(a+5)=*(p+5)，对于D选项，p[5]是个int值，再取*就不对了。",
            "index": 3
        },
        {
            "content": "展开全部\nA机器语言。\n从计算机诞生至今，计算机语言经历了机器语言、汇编语言和高级语言几个阶段。在所有的程序设计语言中，只有机器语言编制的源程序能够被计算机直接理解和执行，用其它程序设计语言编写的程序都必须利用语言处理程序“翻译”成计算机所能识别的机器语言程序。\n扩展资料\n计算机语言的主要分类\n1、解释类\n执行方式类似于我们日常生活中的“同声翻译”，应用程序源代码一边由相应语言的解释器“翻译”成目标代码(机器语言)，一边执行，因此效率比较低，而且不能生成可独立执行的可执行文件，应用程序不能脱离其解释器，但这种方式比较灵活，可以动态地调整、修改应用程序。\n2、编译类",
            "index": 4
        },
        {
            "content": "C 不能在一行上写多条预处理命令 宏里面的参数没有数据类型，它所执行的只是文本的替换。 宏的名称中不能出现空格，否则空格之后的部分都将被替换。",
            "index": 5
        },
        {
            "content": "char s[5]=\"asdf\";\n这句不是赋值而是初始化；\n讲的赋值语句是在程序执行中的赋值，就像\nint a;\nint b;\nb=a; 这是赋值；\n对于字符而言，要赋值就要采用strcpy（s1，s2）这个函数。",
            "index": 6
        },
        {
            "content": "a b c c",
            "index": 7
        },
        {
            "content": "A不对，一个c语言程序有且只能有一个main函数\nD也不对，注释可以在任意位置，常放在1.开头说明程序功能2.某语句后，对此语句功能进行描述",
            "index": 8
        },
        {
            "content": "函数rewind(fp)的作用是：使文件位置指针重新定位到fp文件的开始位置。\n\n函数rewind()是将将文件内部的位置指针重新指向一个流（数据流/文件）的开头\n注意：不是文件指针而是文件内部的位置指针，随着对文件的读写文件的位置指针（指向当前读写字节）向后移动。而文件指针是指向整个文件，如果不重新赋值文件指针不会改变。\nrewind函数作用等同于 (void)fseek(stream, 0L, SEEK_SET)；\n用 法: void rewind(FILE *stream);\n头文件：stdio.h\n返回值：无",
            "index": 9
        },
        {
            "content": "A选项，看下图：\n不用全部记住，记住平时比较常用的就行了，还有记住：算术运算符>关系运算符>逻辑运算符>赋值运算符",
            "index": 10
        },
        {
            "content": "展开全部\n在 K&R 经典教材 The C Programming Language 的2.2节中，对 int 类型是这样描述的\nan integer, typically reflecting the natural size of integers on the host machine\n意思是反映了机器整数类型的 natural size，可是，\n这个 natural size 又是什么意思呢？\n书中后来在谈到 short, int, long 的关系时，又说，这些类型由编译器根据机器自由选择合适的大小，但是 short 和 int 至少 16 位，long 至少 32 位。\n这里的问题是\n编译器是根据什么决定类型大小呢？\n后面书中又提到，这些类型啊，在<limits.h>中都有，我就在ubuntu下查看了 /usr/include/limits.h，里面确实提到\n/* Minimum and maximum values a `signed int' can hold. */\n# define INT_MIN (-INT_MAX - 1)\n# define INT_MAX 2147483647\n\n但是，这也是一种定义，还是没有说出为什么，我现在想知道的是\n为什么\n于是，我想起了那些年扫过的 《深入理解计算机系统》，英文名叫 Computer Systems: A Programmer's Perspective，速查之！\n在2.1节的开头提到，字节(byte)是最小可寻址单位，大多数计算机使用8位的块。 啊，8位，那位又是什么呢？嗯，位是一种存储结构，一个位只能存储0或者1。\n后面2.1.2节中提到\n每台计算机都有一个字长(word size)，指明了整数和指针数据的 nominal size。\n指针是什么，指针就是内存中的地址啊，假如字长为w位，那么地址的数目就是2^w个啊，那一个地址代表多大内存呢？\n前面说了，字节(byte)是最小可寻址单位，所以一个地址代表一个字节。当字长是w位时，地址数目2^w个，共有2^w个字节的内存空间。\n如果计算机字长为32，即传说中的32位计算机，那么它可以表示的内存空间就是 2^32 个字节，这就是传说中的4G啊！\n现在我们是由字长32位，也就是整数的大小32位，推出了内存空间4G。我现在在想：\n是不是一开始是决定内存空间是4G，所以才定下了字长32位的规矩，由此，机器的natural size是32位， 所以，编译器才将C语言中int类型才是32位呢？\n可是我没有证据啊！\n没有证据就尝试推理一下吧。\n我们知道32位机器是由16位机器扩展来的，那为什么要扩展机器字长呢？这个问题原因之一，我们刚才已经解释过了，如果不扩展，那么机器最大寻址空间就比较小，即使我给你一个大内存，你也用不上啊。这可能这也今天我们从32位转到64位的原因吧。\n所以，现在我们明白了，由于我们想要更大的内存地址空间，所以就将字长从16位提升为32位，而字长代表着指针和整数类型的大小，所以最终整数类型就是32位了。\n不过这里还有不少问题。\n字长这东西只是个抽象的概念，方便我们描述机器的一些属性，暂时不谈。\n先说指针。对于机器来说，哪里有什么指针的概念，指针是C语言中的东西，编译成汇编后就没指针这个概念了。但是，指针表示的是内存的地址，而内存的地址又和机器中的什么部件相关呢？\n再说整数。到汇编这一层，整数的概念还存在吗？整数的概念应该是和汇编中的算术指令相关，那么算术指令又和机器中的什么部件相关呢？\n最后，指针是表示内存地址啊，我们有了更大内存，那么内存地址需要更长的位来表示是可以理解的，可是，这关你整数什么事啊？我内存地址32位，整数16位不行吗？\n其实，总的问题就是\n字长都与机器的什么部件相关\n要解释这个问题，我们发现自己不由自主地来到了《深入理解计算机系统》的第四章“处理器体系结构”。\n这一章以一种叫Y86的处理器介绍了处理器体系结构的方方面面。首先介绍了寄存器，寄存器是一种存储部件，存储什么？存储信息，存储信息用来做什么呢？用来计算。我们在C语言中使用一个简单的加法计算，在处理器这一层，就需要使用寄存器来帮助我们计算。我们把一个简单的C语言编译成汇编看看。\n/* test_add.c */\n#include <stdio.h>\n\nint main(void) {\nint a = 1;\nint b = 2;\nint c = a + b;\n\nreturn 0;\n}\n\n使用 GCC 编译一下\ngcc -S test_add.c -o test_add.s\n\n然后查看一下主要代码。\nmovl $1, -12(%ebp)\nmovl $2, -8(%ebp)\n\nmovl -8(%ebp), %eax\nmovl -12(%ebp), %edx\n\naddl %edx, %eax\nmovl %eax, -4(%ebp)\n\n其中的 ebp eax edx 就是寄存器。\n可以看出，数据先放到栈里，再从栈里放到寄存器里，然后再进行加法运算，最后再从寄存器里把结果放回栈里。\n下面的图是书中给出的一个处理器的抽象视图：\n\n栈是什么？栈是一种抽象概念，这里的栈就是指内存。\n书里说了，在32位计算机中，这些寄存器的大小就是32位。可见，\n字长与寄存器大小一样\n除此之外，我们可以看到，需要计算的时候，movl 指令将数据从内存中放到寄存器里，由于内存和寄存器是不同的部件，所以需要一个部件来传递数据，这种部件叫做数据总线。\n寄存器的大小与字长相同，那么这种数据总线每次能传送的数据也应该与字长相同，所以：\n字长与数据总线宽度一样\n另外，再想像一下，你想要从内存中取数据出来，总要告诉内存你取的是哪个地址的数据吧，所以，“地址”这个数据也是要从某个地方传送到内存的。只要传递，就需要有部件支持，这个部件叫做地址总线，地址总线传递地址，地址大小与字长一样，那么，我们可以知道：\n字长与地址总线宽度一样\n好了，到了这里，我们的分析就差不多了，总结一下：\n我们由C语言中int类型的大小，得到了字长这个概念，又从字长这个概念寻找了与其相关的一些机器部件的属性。到现在为此，与字长相关的有:\nint 类型\n指针（即内存地址）\n寄存器\n数据总线\n地址总线\n在 Wikipedia 的 Word(computer_architecture)词条中，我们可以看到自1837年以来，一系列计算机体系结构中与字长相关的一些属性的变化。\n我们再想想，为什么要将这么多种部件都设置成相同长度？我想，可能是因为计算机内部实在太复杂了，各个部件之间需要紧密地配合，共同完成复杂的任务。尤其是数据，需要在各个部件之间传递，如果这些部件之间大小不统一，就会增加机器的复杂度，由于，我们将这些部件大小尽可能统一，进而提出字长这种概念来描述计算机的重要性质。\n到这里，我们再想一下，字长这个概念和这么多部件相关，那么确定字长多大应该不仅仅与内存大小有关系。比如字长代表寄存器的大小，寄存器与机器的运算直接相关，字长变大后，每次能参与计算的值也相应变大，以前我们计算两个很大的数的和时，可能需要动用好几个寄存器，现在咱字长大了，寄存器也大了，只需要两个寄存器就可以了。\n由此可见，字长的确定是一个综合的考量，代表着计算机计算，存储能力的全面提升。",
            "index": 11
        },
        {
            "content": "应该是瀑布模型吧，最早出现的软件开发模型是1970年W·Royce提出的瀑布模型。而且看传统的瀑布模型跟现在我们使用的系统开发步骤是一致的。",
            "index": 12
        },
        {
            "content": "展开全部\n对于 a[3][4]说明有12元素，行从0到2，列从0到3。a[0][4]的列超界。\n数组说明的一般形式为：类型说明符 数组名 [常量表达式]，……； 其中，类型说明符是任一种基本数据类型或构造数据类型。数组名是用户定义的数组标识符。方括号中的常量表达式表示数据元素的个数，也称为数组的长度。\n数组就是一次性定义相同数据类型的一组变量数组定义。\n举例\nint a[10]; 说明整型数组a，有10个元素。若要表示第10个元素，则使用a[9]。第一个则是a[0]。\nfloat b[10],c[20]; 说明实型数组b，有10个元素，实型数组c，有20个元素。\nchar ch[20]; 说明字符数组ch，有20个元素。",
            "index": 13
        },
        {
            "content": "1． 编写程序求数列2/1，3/2，5/3，8/5，13/8，21/13，……的前20项之和。\nmain()\n{\nint n,t,number=20;\nfloat a=2,b=1,s=0;\nfor(n=1;n<=number;n++)\n{\ns=s+a/b;\nt=a;a=a+b;b=t;/*这部分是程序的关键，请读者猜猜t的作用*/\n}\nprintf(\"sum is %9.6f\\n\",s);\n}",
            "index": 14
        },
        {
            "content": "展开全部\n首先，了解下什么是缓冲区：\n电脑内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。\n\n栈——就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。\n\n堆——就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete.如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。\n\n自由存储区——就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。\n\n全局/静态存储区——全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。\n\n常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）\n\n电脑缓冲区就是预留下来的做为急用的那一部分，为暂时置放输出或输入资料的内存。\n\n如何对缓冲区进行操作：\n当我们读写文本文件的时候，采用Reader是非常方便的，比如FileReader，InputStreamReader和BufferedReader。其中最重要的类是InputStreamReader， 它是字节转换为字符的桥梁。你可以在构造器重指定编码的方式，如果不指定的话将采用底层操作系统的默认编码方式，例如GBK等。使用FileReader读取文件：\nFileReader fr = new FileReader(\"ming.txt\");\nint ch = 0;\nwhile((ch = fr.read())!=-1 )\n{\nSystem.out.print((char)ch);\n}\n其中read()方法返回的是读取得下个字符。当然你也可以使用read(char[] ch,int off,int length)这和处理二进制文件的时候类似。\n事实上在FileReader中的方法都是从InputStreamReader中继承过来的。read()方法是比较好费时间的，如果为了提高效率我们可以使用BufferedReader对Reader进行包装，这样可以提高读取得速度，我们可以一行一行的读取文本，使用readLine()方法。\nBufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"ming.txt\")));\nString data = null;\nwhile((data = br.readLine())!=null)\n{\nSystem.out.println(data);\n}\n了解了FileReader操作使用FileWriter写文件就简单了，这里不赘述。\nEg.我的综合实例：\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class testFile {\n/**\n* @param args\n*/\npublic static void main(String[] args) {\n// TODO Auto-generated method stub\n// file(内存)----输入流---->【程序】----输出流---->file(内存)\nFile file = new File(\"d:/temp\", \"addfile.txt\");\ntry {\nfile.createNewFile(); // 创建文件\n} catch (IOException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n}\n\n// 向文件写入内容(输出流)\nString str = \"亲爱的小南瓜！\";\nbyte bt[] = new byte[1024];\nbt = str.getBytes();\ntry {\nFileOutputStream in = new FileOutputStream(file);\ntry {\nin.write(bt, 0, bt.length);\nin.close();\n// boolean success=true;\n// System.out.println(\"写入文件成功\");\n} catch (IOException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n}\n} catch (FileNotFoundException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n}\ntry {\n// 读取文件内容 (输入流)\nFileInputStream out = new FileInputStream(file);\nInputStreamReader isr = new InputStreamReader(out);\nint ch = 0;\nwhile ((ch = isr.read()) != -1) {\nSystem.out.print((char) ch);\n}\n} catch (Exception e) {\n// TODO: handle exception\n}\n}\n}",
            "index": 15
        },
        {
            "content": "enum，保留字不可以用作自定义",
            "index": 16
        },
        {
            "content": "B错是因为多余的是被初始化为零。AC没什么解释的，D的话，数组名传递进函数的话变成指针，这样就有源数据的地址，就可以读写了。另，const只是编译时的检查。",
            "index": 17
        },
        {
            "content": "展开全部\n1、创建两张测试表，\ncreate table test_cj(name VARCHAR(20), remark varchar2(20));\ncreate table test_kc(name VARCHAR(20), remark varchar2(20));\n2、插入测试数据\ninsert into test_cj values('xh','cj_1');\ninsert into test_cj values('kcdh','cj_2');\ninsert into test_cj values('cj','cj_3');\ninsert into test_kc values('kcdh','kc_1');\ninsert into test_kc values('kcm','kc_2');\n3、查询两张表的总记录数，select t.*, rowid from test_cj t union all select t.*, rowid from test_kc t，",
            "index": 18
        },
        {
            "content": "2\n1\n原因分析：x=1，跳进switch(x)里面执行case1\n执行switch（y）,然后执行break跳出switch(y)。由于switch(x)的case1没有break，会去执行switch(x)的case2\n。这样a就++了两次，b\n++了一次",
            "index": 19
        },
        {
            "content": "D",
            "index": 20
        },
        {
            "content": "求解方法是逻辑与（&&）的运算符优先级比 ! 和 < 低，只要 && 两侧的表达式只有都为true时结果为true，如果有一个为 false，那么结果必为false。\n1\n2\n3\n4\nx>=y //  => 43>=0 为 true\nch < 'B' // => 'A' < 'B' 为 true\n!y // => true\n(x>=y&&ch<'B'&&!y) // 结果true\n运算符优先级\nASCII",
            "index": 21
        },
        {
            "content": "在线性表的顺序存储结构中，元素之间的逻辑关系是通过（\n元素的存储地址\n）决定的；在线性表的链接存储中，元素之间的逻辑关系是通过（\n结点中的指针\n）决定的。",
            "index": 22
        },
        {
            "content": "线性表的占用连续的存储空间，链式存储可以零散分配存储空间。\n链式比线性表做插入、删除等操作的效率快\n线性表取值比链式方便",
            "index": 23
        },
        {
            "content": "授人鱼不如授人渔。\n\n我来帮你分析吧，\na=1,b=2,c=3\n1、 如果a大于b 那么 b赋值给a，（2肯定比1大 是不是？明显不成立，跳过，不理它）\n接下来\n2、如果a大于c 那么c赋值给a，（明显1不大于3嘛，所以还是不管他）\n最终结果 a 还是最开始的时候的值，那就是1.",
            "index": 24
        },
        {
            "content": "展开全部\nshort是占两个字节。\nshort在C语言中是定义一种整型变量家族的一种，shorti；表示定义一个短整型的变量i。\n依据程序编译器的不同short定义的字节数不同，标准定义short短整型变量不得低于16位，即两个字节，编译器头文件夹里面的limits.h定义了short能表示的大小：SHRT_MIN~SHRT_MAX，在32位平台下如windows(32位)中short一般为16位。\n扩展资料：\nshort、int、long、char、float、double 这六个关键字代表C 语言里的六种基本数据类型。\n在32 位的系统上\nshort 占据的内存大小是2 个byte（字节）；\nint占据的内存大小是4 个byte（字节）；\nlong占据的内存大小是4 个byte（字节）；",
            "index": 25
        },
        {
            "content": "展开全部\n选择D。\n%是求余运算符，也叫模除运算符，用于求余数。%要求两个操作数均为整数（或可以隐式转换成整数的类型）。\n标准规定：\n1、如果%左边的操作数为负数时，则模除的结果为负数或者0，\n2、如果%左边的操作数为正数时，则模除的结构为正数或者0。\n扩展资料：\nC语言中各运算符的结合性分为两种，即左结合性(自左至右)和右结合性(自右至左)。例如算术运算符的结合性是自左至右，即先左后右。如有表达式x-y+z 则y 应先与“-”号结合，执行x-y 运算，然后再执行+z 的运算。这种自左至右的结合 方向就称为“左结合性”。\n而自右至左的结合方向称为“右结合性”。最典型的右结合 性运算符是赋值运算符。如x=y=z,由于“=”的右结合性，应先执行y=z 再执行x=(y=z)运算。C语言运算符中有不少为右结合性，应注意区别。\n参考资料来源：百度百科-C语言运算符",
            "index": 26
        },
        {
            "content": "选a\nB：c函数不可以嵌套定义，只可以递归调用。\n\nC：不一定有返回值\n\nD：没打全",
            "index": 27
        },
        {
            "content": "展开全部\n问题少写一个答案吧\nC语言中要求对变量作强制定义的主要理由是()。\nA:便于移植\nB:便于写文件\nC:便于编辑预处理程序的处理\nD:便于确定类型和分配空间\nA、B：错误。这两个和C语言的语言特性完全没有关系。和函数库比较相关。\nC：错误。事实上，预处理器只通过预处理命令确认标识符（例如宏定义）而完全不检查除此之外的标识符以及它们的类型。剩余的定义和类型检查是预处理(preprocessing)阶段结束后翻译(translating)阶段生成目标文件代码的同时进行的。\nD：正确，只有明确的定义才能保证类型的一致性和分配空间大小的明确性。",
            "index": 28
        },
        {
            "content": "根据楼主提供的答案是3，做一点分析。\nchar c[]字符数组是不是打错了，应该为char c[]=\"\\t\\v\\\\\\0will\\n\"\n\\t 表示一个字符；\n\\v 表示一个字符；\n\\\\ 表示一个字符；\n\\0 表示字符终止。",
            "index": 29
        },
        {
            "content": "展开全部\n1、答案是D\n在C语言中，char型数据是将一个字符常量放到一个字符变量中，并不是把该字符本身放到内存单元中去，而是将该字符的相应的ASCII代码放到存储单元中。\nC语言使字符型数据和整型数据之间可以通用。一个字符数据既可以以字符形式输出，也可以以整数形式输出。以字符形式输出时，需要先将存储单元中的ASCII码转换成相应字符，然后输出。以整数形式输出时，直接将ASCII码作为整数输出。\n2、原码、反码和补码是对数字的二进制定点的表示方法。\n扩展资料：\n1、在计算机中，所有的数据在存储和运算时都要使用二进制数表示（因为计算机用高电平和低电平分别表示1和0）\nASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符。",
            "index": 30
        },
        {
            "content": "A 新改的。auto i = 5; 自动把i定义为int ---》C++里加的，c里有这个？疑惑\nB 貌似这个是指示尽量用寄存器？\nC 静态，不用堆栈\nD 外部引用 代表定义不在此文件\n\n所以看上去 不知道该选啥",
            "index": 31
        },
        {
            "content": "A. ++ //一元运算符，自增运算符\nB. += //赋值运算符\nC. || //逻辑运算符\nD. != //关系运算符（比较运算符\n\n1.C中规定的优先顺序：\n一元算术运算符->二元算术运算符->关系运算符->逻辑运算符->赋值运算符\n2.因此，正确选择是：A",
            "index": 32
        },
        {
            "content": "展开全部\n有编译错误。\n数组之间拷贝不能直接使用a=b，而是可以使用字符串拷贝函数strcpy。而且数组a的长度只有3，而数组b有5个字符，还不包括结尾字符。\n字符串拷贝函数strcpy格式：strcpy （字符数组名1，字符数组名2） 的功能：把字符数组2中的字符串拷贝到字符数组1中。串结束标志“”也一同拷贝。字符数名2， 也可以是一个字符串常量。这时相当于把一个字符串赋予一个字符数组。\n本函数要求字符数组1应有足够的长度，否则不能全部装入所拷贝的字符串。\n扩展资料：\n1.可以只给部分元素赋初值。当{ }中值的个数少于元素个数时，只给前面部分元素赋值。例如：static int a[10]={0,1,2,3,4};表示只给a[0]～a[4]5个元素赋值，而后5个元素自动赋0值。\n2.只能给元素逐个赋值，不能给数组整体赋值。例如给十个元素全部赋1值，只能写为：static int a[10]={1,1,1,1,1,1,1,1,1,1};而不能写为：static int a[10]=1。\n3.若不给可初始化的数组赋初值，则全部元素均为0值。\n4.假如给全部元素赋值，则在数组说明中， 可以不给出数组元素的个数。例如：static int a[5]={1,2,3,4,5};可写为：static int a[]={1,2,3,4,5};动态赋值可以在程序执行过程中，对数组作动态赋值。这时可用循环语句配合scanf函数逐个对数组元素赋值。",
            "index": 33
        },
        {
            "content": "D形参是虚拟的，不占用存储单元\n\n解释：\n只有当函数调用，发生实参向形参的数据传递时，系统才分配给形参存储单元，调用完之后就释放，可以概括为“用之建，用完撤”,所以形参不占内存单元。\n实参是系统分配开始就分配内存给它的，程序结束之后才释放，所以实参是占内存单元的。",
            "index": 34
        },
        {
            "content": "A、草原生态系统既不属于森林生态系统，又不属于海洋生态系统，A错误；\nB、“J”型增长和“S”型增长为种群在不同条件下的数量变化曲线，B正确；\nC、．在一定区域内，同种生物的所有个体构成一个种群；生物群落是同一时间内聚集在一定区域中各种生物种群的集合；生态系统则包括生物群落及其生活的无机环境，故三者之间为包含关系，C正确；\nD、物质循环是能量流动的载体，能量流动是物质循环的动力，二者相互联系，密不可分，D正确．\n故选：A．",
            "index": 35
        },
        {
            "content": "字符型常量的十进制ASCII值0~255, 所以A错\nB，C加了双引号，都表示字符串常量\nD，是单引号，正确",
            "index": 36
        },
        {
            "content": "展开全部\n#include<stdio.h>\nint\nmain()//主函数，有且只有一个\n{\nchar\nc1=97,c2=98;//定义字符变量c1,c2并给这两个变量赋予初始值\n//这里给的97,98是ASCII码分别代表字符'a',\n'b'这里等效于:char\nc1='a',c2='b';\nprintf(\"%d\n%c\",c1,c2);//%d是以整型输出，%s是以字符型输出\n字符a以整型输出就是输出它的\nASCII码值，\n//字符b以字符型输出就是输出字符b\n}",
            "index": 37
        },
        {
            "content": "答案为：D\n\n因为C中的规定是非零数字表示真，0表示假，而逻辑运算就是对真假进行计算，所以在C中是任何类型的数据都可以进行逻辑运算，只要是非零数字就会被认为是真，再进行逻辑运算时按真处理。\n\n举例子：printf(\"%d% d\\n\",3.1||3.2,3.14&&0.0); //输出1 0",
            "index": 38
        },
        {
            "content": "C语言中的逻辑值“真”是用T表示（True，真） 值，逻辑值“假”是用 F（False，假）。\n在编程语言中表示 T（True，真） 值和 F（False，假）值的数据类型叫做布尔类型，在 C 语言中通常用 int 类型来表示，非 0 表示 T，0 表示 F。\n扩展资料：\n\n当表达式进行&&运算时，只要有一个为假，总的表达式就为内假，只有当所有都为 真时，总的式子才为真。当表达式进行||运算时，只要有一个为真，总的值就为真，只有当所有的都为假时，总的式子才为假。\n逻辑非(!)运算是把相应的变量 数据转换为相应的真/假值。若原先为假，则容逻辑非以后为真，若原先为真，则逻辑非以后为假。",
            "index": 39
        },
        {
            "content": "a[4-2*2]=a[0]=1",
            "index": 40
        },
        {
            "content": "你这个是考优先级的问题，口诀\n圆方括号、箭头一句号， 自增自减非反负、针强地址长度，\n乘除，加减，再移位，\n小等大等、等等不等，\n八位与，七位异，六位或，五与，四或，三疑，二赋，一真逗。\n其中“，”号为一个等级分段。\n选A",
            "index": 41
        },
        {
            "content": "展开全部\n运算符运算等级如下\n其中 1级优先级最高，15级最低，\n1级优先级 左结合\n() 圆括号 \n[] 下标运算符 \n-> 指向结构体成员运算符 \n. 结构体成员运算符 \n2级优先级 右结合 \n! 逻辑非运算符 \n~ 按位取反运算符 \n++ 自增运算符 \n-- 自减运算符 \n- 负号运算符 \n(类型) 类型转换运算符 \n* 指针运算符 \n& 地址与运算符 \nsizeof 长度运算符 ",
            "index": 42
        },
        {
            "content": "不是，使用c语言编写程序时，c语言程序库内包含了printf和scanf这两个函数，当你需要输入输出时，就要输入这两个函数，编译时c语言程序库则调用这两个函数，所以c语言本身是不能输入输出的。就像你要写字，你是不能直接用手写的，而要借用一直笔才能达到目的。懂了吗？欢迎追问，如果好请采纳。",
            "index": 43
        },
        {
            "content": "展开全部\n#include<stdio.h>\n#include<stdlib.h>\n#include<malloc.h>\n\n#defineTRUE 1\n#defineERROR 0\n#defineMAX 30\ntypedefint Status;\n\ntypedefstruct{\ncharoption1[30],option2[30],option3[30],option4[30],subject[150];\nchar result;\n}TestNode;\nTestNodeTestquestions[MAX];\n\nStatusSaveNode(int N) //把结构体数组保存到文件\"cheng\"中,如成功保存返回TRUE,否则返回ERROR\n\n{ int i;\nFILE *fp;\nif((fp=fopen(\"cheng\",\"wb\"))==NULL)return ERROR;\nfor(i=0;i<N;i++)\nfwrite(&Testquestions[i],sizeof(TestNode),1,fp);\nfclose(fp);\nreturn TRUE;\n}\n\nStatusReadNode(int &N) //从文件读出结构体数组的内,如成功读取返回TRUE,否则返回ERROR\n\n{ FILE *fp;\nint i=0;\nif((fp=fopen(\"cheng\",\"rb\"))==NULL)return ERROR;\nwhile(!feof(fp))// 用feof检测文件是否结束,如果结束,返回正确\n{ fread(&Testquestions[i],sizeof(TestNode),1,fp);\ni++;\n}\nN=i-1;\nreturn TRUE;\n}\n\nvoidInputTitle(int N)// 输入N道试题数据\n{\nint i;\nfor(i=0;i<N;i++)\n{ printf(\"请输入第%d道题题目、题干和选项:\\n\",i+1);//输入结构体元素内容\nprintf(\"请输入题目:\");\ngets(Testquestions[i].subject);\nprintf(\"请输入选项A:\");\ngets(Testquestions[i].option1);\nprintf(\"请输入选项B:\");\ngets(Testquestions[i].option2);\nprintf(\"请输入选项C:\");\ngets(Testquestions[i].option3);\nprintf(\"请输入选项D:\");\ngets(Testquestions[i].option4);\nprintf(\"请输入答案:\");\nscanf(\"%c\",&Testquestions[i].result);getchar();\nsystem(\"cls\"); //清屏\n}\n}\n\nStatusInsertNode(int &N) //插入试题内容\n{\nif(N>MAX) return ERROR;\nprintf(\"请输入所要插入题题目、题干和选项:\\n\");\nprintf(\"请输入题目：\");\ngets(Testquestions[N].subject);\nprintf(\"请输入选项A：\");\ngets(Testquestions[N].option1);\nprintf(\"请输入选项B：\");\ngets(Testquestions[N].option2);\nprintf(\"请输入选项C：\");\ngets(Testquestions[N].option3);\nprintf(\"请输入选项D：\");\ngets(Testquestions[N].option4);\nprintf(\"请输入答案：\");\nscanf(\"%c\",&Testquestions[N].result);getchar();\nN++; //N表示结构体数组长度,通过加&号使其值能返回\nreturn TRUE;\n}\n\nStatusDeleteNode(int n)//删除数组中的第n个元素\n{\nreturn TRUE;\n}\n\nvoidprintNode(TestNode p,int n)//输出第n道题题目\n{\nprintf(\"(%d) \",n);\nprintf(\"%s\\n\",p.subject);\nprintf(\" A %s \",p.option1);\nprintf(\" B %s \\n\",p.option2);\nprintf(\" C %s \",p.option3);\nprintf(\" D %s \",p.option4);\n}\n\nStatus Match(TestNode p,char m)//判断m是否为p题目的答案，若是返回TRUE，否则返回ERROR\n{\nif(m==p.result) return TRUE;\nelse return ERROR;\n}\n\nvoidanswer(int sum)//进行答题\n{\n\nint i,score=0,Num;\nchar r;\n\nfor(i=1;i<=sum;i++)\n{ Num=rand()%sum; //随机函数,以随机选定何题进行解答\nprintNode(Testquestions[Num],Num+1);\nprintf(\"\\n请输入答案:\");\nscanf(\"%c\",&r);getchar();\nif( Match(Testquestions[Num],r)) //调用函数IsMatch判断所输入的答案与标准答案是否相同\n{ printf(\"\\n答案正确!\\n\");\nscore++;\n}\nelse printf(\"\\n答案错误!\\n\");\n}\nprintf(\"\\n你的总成绩为:%d\\n\",score);\n}\n\nvoidmain()\n{ char flag='N';\nint N=0,i, sum,score=0,chose;\n\n/*printf(\"输入想建立的题目文件题目数：\");\nscanf(\"%d\",&N);getchar();\nInputTitle(N);*/\nReadNode(N);\nwhile(flag=='N'||flag=='n')\n{ printf(\"\\t\\t\\t单项选择题标准化考试系统\\n\");\nprintf(\"\\n\");\nprintf(\" \\t\\t\\t1 进行答题并判卷\\n\");\nprintf(\" \\t\\t\\t2 显示整张试卷内容\\n\");\nprintf(\" \\t\\t\\t3 插入试题\\n\");\nprintf(\" \\t\\t\\t4 保存到文件\\n\");\nprintf(\" \\t\\t\\t5 退出系统\\n\");\nprintf(\" \\t\\t\\t 请选择:\");\nscanf(\"%d\",&chose);getchar();\nswitch(chose)\n{case1:system(\"cls\");\nprintf(\"请输入你想要的答题数目:\");\nscanf(\"%d\",&sum);getchar();\nanswer(sum);\nbreak;\ncase 2:system(\"cls\");\nfor(i=1;i<=N;i++)\n{ printNode(Testquestions[i-1],i);\nprintf(\"\\n\");\n}\nbreak;\ncase 3:system(\"cls\");InsertNode(N);break;\ncase 4:system(\"cls\");\nif(SaveNode(N)) printf(\"保存成功!\\n\");\nelse printf(\"保存失败!\\n\");break;\ncase 5:printf(\"你将退出系统(Y or N)?\");\nscanf(\"%c\",&flag);getchar();\nif(flag=='Y'||flag=='y') exit(0);\nsystem(\"cls\");break;\ndefault:printf(\"请输入正确选择!\\n\");\n}\n}\n}",
            "index": 44
        },
        {
            "content": "对错对错对对对错",
            "index": 45
        },
        {
            "content": "展开全部\n你要的全在这里一章里!\n自己慢慢找你要的资料吧!\n\n11 结构体与共用体 1\n11.1 定义一个结构的一般形式 1\n11.2 结构类型变量的说明 2\n11.3 结构变量成员的表示方法 4\n11.4 结构变量的赋值 4\n11.5 结构变量的初始化 5\n11.6 结构数组的定义 5\n11.7 结构指针变量的说明和使用 7\n11.7.1 指向结构变量的指针 7\n11.7.2 指向结构数组的指针 9\n11.7.3 结构指针变量作函数参数 10\n11.8 动态存储分配 11\n11.9 链表的概念 12\n11.10 枚举类型 14\n11.10.1 枚举类型的定义和枚举变量的说明 14\n11.10.2 枚举类型变量的赋值和使用 15\n11.11 类型定义符typedef 16\n11 结构体与共用体\n11.1 定义一个结构的一般形式\n在实际问题中，一组数据往往具有不同的数据类型。例如，在学生登记表中，姓名应为字符型；学号可为整型或字符型；年龄应为整型；性别应为字符型；成绩可为整型或实型。 显然不能用一个数组来存放这一组数据。因为数组中各元素的类型和长度都必须一致，以便于编译系统处理。为了解决这个问题，C语言中给出了另一种构造数据类型——“结构（structure）”或叫“结构体”。 它相当于其它高级语言中的记录。“结构”是一种构造类型，它是由若干“成员”组成的。每一个成员可以是一个基本数据类型或者又是一个构造类型。结构既是一种“构造”而成的数据类型，那么在说明和使用之前必须先定义它，也就是构造它。如同在说明和调用函数之前要先定义函数一样。\n定义一个结构的一般形式为：\nstruct 结构名\n{成员表列};\n成员表列由若干个成员组成，每个成员都是该结构的一个组成部分。对每个成员也必须作类型说明，其形式为：\n类型说明符 成员名;\n成员名的命名应符合标识符的书写规定。例如：\nstruct stu\n{\nint num;\nchar name[20];\nchar sex;\nfloat score;\n};\n在这个结构定义中，结构名为stu，该结构由4个成员组成。第一个成员为num，整型变量；第二个成员为name，字符数组；第三个成员为sex，字符变量；第四个成员为score，实型变量。应注意在括号后的分号是不可少的。结构定义之后，即可进行变量说明。凡说明为结构stu的变量都由上述4个成员组成。由此可见， 结构是一种复杂的数据类型，是数目固定，类型不同的若干有序变量的集合。\n11.2 结构类型变量的说明\n说明结构变量有以下三种方法。以上面定义的stu为例来加以说明。\n1. 先定义结构，再说明结构变量。\n如：\nstruct stu\n{\nint num;\nchar name[20];\nchar sex;\nfloat score;\n};\nstruct stu boy1,boy2;\n说明了两个变量boy1和boy2为stu结构类型。也可以用宏定义使一个符号常量来表示一个结构类型。\n例如：\n#define STU struct stu\nSTU\n{\nint num;\nchar name[20];\nchar sex;\nfloat score;\n};\nSTU boy1,boy2;\n2. 在定义结构类型的同时说明结构变量。\n例如：\nstruct stu\n{\nint num;\nchar name[20];\nchar sex;\nfloat score;\n}boy1,boy2;\n这种形式的说明的一般形式为：\nstruct 结构名\n{\n成员表列\n}变量名表列;\n3. 直接说明结构变量。\n例如：\nstruct\n{\nint num;\nchar name[20];\nchar sex;\nfloat score;\n}boy1,boy2;\n这种形式的说明的一般形式为：\nstruct\n{\n成员表列\n}变量名表列;\n第三种方法与第二种方法的区别在于第三种方法中省去了结构名，而直接给出结构变量。三种方法中说明的boy1,boy2变量都具有下图所示的结构。\n\n说明了boy1,boy2变量为stu类型后，即可向这两个变量中的各个成员赋值。在上述stu结构定义中，所有的成员都是基本数据类型或数组类型。\n成员也可以又是一个结构，即构成了嵌套的结构。例如，下图给出了另一个数据结构。\n\n按图可给出以下结构定义：\nstruct date\n{\nint month;\nint day;\nint year;\n};\nstruct{\nint num;\nchar name[20];\nchar sex;\nstruct date birthday;\nfloat score;\n}boy1,boy2;\n首先定义一个结构date，由month(月)、day(日)、year(年) 三个成员组成。 在定义并说明变量 boy1 和 boy2 时，其中的成员birthday被说明为data结构类型。成员名可与程序中其它变量同名，互不干扰。\n11.3 结构变量成员的表示方法\n在程序中使用结构变量时，往往不把它作为一个整体来使用。在ANSI C中除了允许具有相同类型的结构变量相互赋值以外，一般对结构变量的使用，包括赋值、输入、输出、运算等都是通过结构变量的成员来实现的。\n表示结构变量成员的一般形式是：\n结构变量名.成员名\n例如：\nboy1.num 即第一个人的学号\nboy2.sex 即第二个人的性别\n如果成员本身又是一个结构则必须逐级找到最低级的成员才能使用。\n例如：\nboy1.birthday.month\n即第一个人出生的月份成员可以在程序中单独使用，与普通变量完全相同。\n11.4 结构变量的赋值\n结构变量的赋值就是给各成员赋值。可用输入语句或赋值语句来完成。\n【例11.1】给结构变量赋值并输出其值。\nmain()\n{\nstruct stu\n{\nint num;\nchar *name;\nchar sex;\nfloat score;\n} boy1,boy2;\nboy1.num=102;\nboy1.name=\"Zhang ping\";\nprintf(\"input sex and score\\n\");\nscanf(\"%c %f\",&boy1.sex,&boy1.score);\nboy2=boy1;\nprintf(\"Number=%d\\nName=%s\\n\",boy2.num,boy2.name);\nprintf(\"Sex=%c\\nScore=%f\\n\",boy2.sex,boy2.score);\n}\n\n本程序中用赋值语句给num和name两个成员赋值，name是一个字符串指针变量。用scanf函数动态地输入sex和score成员值，然后把boy1的所有成员的值整体赋予boy2。最后分别输出boy2的各个成员值。本例表示了结构变量的赋值、输入和输出的方法。\n11.5 结构变量的初始化\n和其他类型变量一样，对结构变量可以在定义时进行初始化赋值。\n【例11.2】对结构变量初始化。\nmain()\n{\nstruct stu /*定义结构*/\n{\nint num;\nchar *name;\nchar sex;\nfloat score;\n}boy2,boy1={102,\"Zhang ping\",'M',78.5};\nboy2=boy1;\nprintf(\"Number=%d\\nName=%s\\n\",boy2.num,boy2.name);\nprintf(\"Sex=%c\\nScore=%f\\n\",boy2.sex,boy2.score);\n}\n\n本例中，boy2,boy1均被定义为外部结构变量，并对boy1作了初始化赋值。在main函数中，把boy1的值整体赋予boy2，然后用两个printf语句输出boy2各成员的值。\n11.6 结构数组的定义\n数组的元素也可以是结构类型的。因此可以构成结构型数组。结构数组的每一个元素都是具有相同结构类型的下标结构变量。在实际应用中，经常用结构数组来表示具有相同数据结构的一个群体。如一个班的学生档案，一个车间职工的工资表等。\n方法和结构变量相似，只需说明它为数组类型即可。\n例如：\nstruct stu\n{\nint num;\nchar *name;\nchar sex;\nfloat score;\n}boy[5];\n定义了一个结构数组boy，共有5个元素，boy[0]～boy[4]。每个数组元素都具有struct stu的结构形式。对结构数组可以作初始化赋值。\n例如：\nstruct stu\n{\nint num;\nchar *name;\nchar sex;\nfloat score;\n}boy[5]={\n{101,\"Li ping\",\"M\",45},\n{102,\"Zhang ping\",\"M\",62.5},\n{103,\"He fang\",\"F\",92.5},\n{104,\"Cheng ling\",\"F\",87},\n{105,\"Wang ming\",\"M\",58};\n}\n当对全部元素作初始化赋值时，也可不给出数组长度。\n【例11.3】计算学生的平均成绩和不及格的人数。\nstruct stu\n{\nint num;\nchar *name;\nchar sex;\nfloat score;\n}boy[5]={\n{101,\"Li ping\",'M',45},\n{102,\"Zhang ping\",'M',62.5},\n{103,\"He fang\",'F',92.5},\n{104,\"Cheng ling\",'F',87},\n{105,\"Wang ming\",'M',58},\n};\nmain()\n{\nint i,c=0;\nfloat ave,s=0;\nfor(i=0;i<5;i++)\n{\ns+=boy[i].score;\nif(boy[i].score<60) c+=1;\n}\nprintf(\"s=%f\\n\",s);\nave=s/5;\nprintf(\"average=%f\\ncount=%d\\n\",ave,c);\n}\n\n本例程序中定义了一个外部结构数组boy，共5个元素，并作了初始化赋值。在main函数中用for语句逐个累加各元素的score 成员值存于s之中，如score的值小于60(不及格)即计数器C加1，循环完毕后计算平均成绩，并输出全班总分，平均分及不及格人数。\n【例11.4】建立同学通讯录\n#include\"stdio.h\"\n#define NUM 3\nstruct mem\n{\nchar name[20];\nchar phone[10];\n};\nmain()\n{\nstruct mem man[NUM];\nint i;\nfor(i=0;i<NUM;i++)\n{\nprintf(\"input name:\\n\");\ngets(man[i].name);\nprintf(\"input phone:\\n\");\ngets(man[i].phone);\n}\nprintf(\"name\\t\\t\\tphone\\n\\n\");\nfor(i=0;i<NUM;i++)\nprintf(\"%s\\t\\t\\t%s\\n\",man[i].name,man[i].phone);\n}\n\n本程序中定义了一个结构mem，它有两个成员name和phone用来表示姓名和电话号码。在主函数中定义man为具有mem 类型的结构数组。在for语句中，用gets函数分别输入各个元素中两个成员的值。然后又在for语句中用printf语句输出各元素中两个成员值。\n11.7 结构指针变量的说明和使用\n11.7.1 指向结构变量的指针\n一个指针变量当用来指向一个结构变量时，称之为结构指针变量。结构指针变量中的值是所指向的结构变量的首地址。通过结构指针即可访问该结构变量，这与数组指针和函数指针的情况是相同的。\n结构指针变量说明的一般形式为：\nstruct 结构名 *结构指针变量名\n例如，在前面的例题中定义了stu这个结构，如要说明一个指向stu的指针变量pstu，可写为：\nstruct stu *pstu;\n当然也可在定义stu结构时同时说明pstu。与前面讨论的各类指针变量相同，结构指针变量也必须要先赋值后才能使用。\n赋值是把结构变量的首地址赋予该指针变量，不能把结构名赋予该指针变量。如果boy是被说明为stu类型的结构变量，则：\npstu=&boy\n是正确的，而：\npstu=&stu\n是错误的。\n结构名和结构变量是两个不同的概念，不能混淆。结构名只能表示一个结构形式，编译系统并不对它分配内存空间。只有当某变量被说明为这种类型的结构时，才对该变量分配存储空间。因此上面&stu这种写法是错误的，不可能去取一个结构名的首地址。有了结构指针变量，就能更方便地访问结构变量的各个成员。\n其访问的一般形式为：\n(*结构指针变量).成员名\n或为：\n结构指针变量->成员名\n例如：\n(*pstu).num\n或者：\npstu->num\n应该注意(*pstu)两侧的括号不可少，因为成员符“.”的优先级高于“*”。如去掉括号写作*pstu.num则等效于*(pstu.num)，这样，意义就完全不对了。\n下面通过例子来说明结构指针变量的具体说明和使用方法。\n【例11.5】\nstruct stu\n{\nint num;\nchar *name;\nchar sex;\nfloat score;\n} boy1={102,\"Zhang ping\",'M',78.5},*pstu;\nmain()\n{\npstu=&boy1;\nprintf(\"Number=%d\\nName=%s\\n\",boy1.num,boy1.name);\nprintf(\"Sex=%c\\nScore=%f\\n\\n\",boy1.sex,boy1.score);\nprintf(\"Number=%d\\nName=%s\\n\",(*pstu).num,(*pstu).name);\nprintf(\"Sex=%c\\nScore=%f\\n\\n\",(*pstu).sex,(*pstu).score);\nprintf(\"Number=%d\\nName=%s\\n\",pstu->num,pstu->name);\nprintf(\"Sex=%c\\nScore=%f\\n\\n\",pstu->sex,pstu->score);\n}\n\n本例程序定义了一个结构stu，定义了stu类型结构变量boy1并作了初始化赋值，还定义了一个指向stu类型结构的指针变量pstu。在main函数中，pstu被赋予boy1的地址，因此pstu指向boy1。然后在printf语句内用三种形式输出boy1的各个成员值。从运行结果可以看出：\n结构变量.成员名\n(*结构指针变量).成员名\n结构指针变量->成员名\n这三种用于表示结构成员的形式是完全等效的。\n11.7.2 指向结构数组的指针\n指针变量可以指向一个结构数组，这时结构指针变量的值是整个结构数组的首地址。结构指针变量也可指向结构数组的一个元素，这时结构指针变量的值是该结构数组元素的首地址。\n设ps为指向结构数组的指针变量，则ps也指向该结构数组的0号元素，ps+1指向1号元素，ps+i则指向i号元素。这与普通数组的情况是一致的。\n【例11.6】用指针变量输出结构数组。\nstruct stu\n{\nint num;\nchar *name;\nchar sex;\nfloat score;\n}boy[5]={\n{101,\"Zhou ping\",'M',45},\n{102,\"Zhang ping\",'M',62.5},\n{103,\"Liou fang\",'F',92.5},\n{104,\"Cheng ling\",'F',87},\n{105,\"Wang ming\",'M',58},\n};\nmain()\n{\nstruct stu *ps;\nprintf(\"No\\tName\\t\\t\\tSex\\tScore\\t\\n\");\nfor(ps=boy;ps<boy+5;ps++)\nprintf(\"%d\\t%s\\t\\t%c\\t%f\\t\\n\",ps->num,ps->name,ps->sex,ps->score);\n}\n\n在程序中，定义了stu结构类型的外部数组boy并作了初始化赋值。在main函数内定义ps为指向stu类型的指针。在循环语句for的表达式1中，ps被赋予boy的首地址，然后循环5次，输出boy数组中各成员值。\n应该注意的是，一个结构指针变量虽然可以用来访问结构变量或结构数组元素的成员，但是，不能使它指向一个成员。也就是说不允许取一个成员的地址来赋予它。因此，下面的赋值是错误的。\nps=&boy[1].sex;\n而只能是：\nps=boy;(赋予数组首地址)\n或者是：\nps=&boy[0];(赋予0号元素首地址)\n11.7.3 结构指针变量作函数参数\n在ANSI C标准中允许用结构变量作函数参数进行整体传送。但是这种传送要将全部成员逐个传送，特别是成员为数组时将会使传送的时间和空间开销很大，严重地降低了程序的效率。因此最好的办法就是使用指针，即用指针变量作函数参数进行传送。这时由实参传向形参的只是地址，从而减少了时间和空间的开销。\n【例11.7】计算一组学生的平均成绩和不及格人数。用结构指针变量作函数参数编程。\nstruct stu\n{\nint num;\nchar *name;\nchar sex;\nfloat score;}boy[5]={\n{101,\"Li ping\",'M',45},\n{102,\"Zhang ping\",'M',62.5},\n{103,\"He fang\",'F',92.5},\n{104,\"Cheng ling\",'F',87},\n{105,\"Wang ming\",'M',58},\n};\nmain()\n{\nstruct stu *ps;\nvoid ave(struct stu *ps);\nps=boy;\nave(ps);\n}\nvoid ave(struct stu *ps)\n{\nint c=0,i;\nfloat ave,s=0;\nfor(i=0;i<5;i++,ps++)\n{\ns+=ps->score;\nif(ps->score<60) c+=1;\n}\nprintf(\"s=%f\\n\",s);\nave=s/5;\nprintf(\"average=%f\\ncount=%d\\n\",ave,c);\n}\n\n本程序中定义了函数ave，其形参为结构指针变量ps。boy被定义为外部结构数组，因此在整个源程序中有效。在main函数中定义说明了结构指针变量ps，并把boy的首地址赋予它，使ps指向boy数组。然后以ps作实参调用函数ave。在函数ave中完成计算平均成绩和统计不及格人数的工作并输出结果。\n由于本程序全部采用指针变量作运算和处理，故速度更快，程序效率更高。\n11.8 动态存储分配\n在数组一章中，曾介绍过数组的长度是预先定义好的，在整个程序中固定不变。C语言中不允许动态数组类型。\n例如：\nint n;\nscanf(\"%d\",&n);\nint a[n];\n用变量表示长度，想对数组的大小作动态说明，这是错误的。但是在实际的编程中，往往会发生这种情况，即所需的内存空间取决于实际输入的数据，而无法预先确定。对于这种问题，用数组的办法很难解决。为了解决上述问题，C语言提供了一些内存管理函数，这些内存管理函数可以按需要动态地分配内存空间，也可把不再使用的空间回收待用，为有效地利用内存资源提供了手段。\n常用的内存管理函数有以下三个：\n1. 分配内存空间函数malloc\n调用形式：\n(类型说明符*)malloc(size)\n功能：在内存的动态存储区中分配一块长度为\"size\"字节的连续区域。函数的返回值为该区域的首地址。\n“类型说明符”表示把该区域用于何种数据类型。\n(类型说明符*)表示把返回值强制转换为该类型指针。\n“size”是一个无符号数。\n例如：\npc=(char *)malloc(100);\n表示分配100个字节的内存空间，并强制转换为字符数组类型，函数的返回值为指向该字符数组的指针，把该指针赋予指针变量pc。\n2. 分配内存空间函数 calloc\ncalloc 也用于分配内存空间。\n调用形式：\n(类型说明符*)calloc(n,size)\n功能：在内存动态存储区中分配n块长度为“size”字节的连续区域。函数的返回值为该区域的首地址。\n(类型说明符*)用于强制类型转换。\ncalloc函数与malloc 函数的区别仅在于一次可以分配n块区域。\n例如：\nps=(struet stu*)calloc(2,sizeof(struct stu));\n其中的sizeof(struct stu)是求stu的结构长度。因此该语句的意思是：按stu的长度分配2块连续区域，强制转换为stu类型，并把其首地址赋予指针变量ps。\n2. 释放内存空间函数free\n调用形式：\nfree(void*ptr);\n功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，它指向被释放区域的首地址。被释放区应是由malloc或calloc函数所分配的区域。\n【例11.8】分配一块区域，输入一个学生数据。\nmain()\n{\nstruct stu\n{\nint num;\nchar *name;\nchar sex;\nfloat score;\n} *ps;\nps=(struct stu*)malloc(sizeof(struct stu));\nps->num=102;\nps->name=\"Zhang ping\";\nps->sex='M';\nps->score=62.5;\nprintf(\"Number=%d\\nName=%s\\n\",ps->num,ps->name);\nprintf(\"Sex=%c\\nScore=%f\\n\",ps->sex,ps->score);\nfree(ps);\n}\n\n本例中，定义了结构stu，定义了stu类型指针变量ps。然后分配一块stu大内存区，并把首地址赋予ps，使ps指向该区域。再以ps为指向结构的指针变量对各成员赋值，并用printf输出各成员值。最后用free函数释放ps指向的内存空间。整个程序包含了申请内存空间、使用内存空间、释放内存空间三个步骤，实现存储空间的动态分配。\n11.9 链表的概念\n在例7.8中采用了动态分配的办法为一个结构分配内存空间。每一次分配一块空间可用来存放一个学生的数据，我们可称之为一个结点。有多少个学生就应该申请分配多少块内存空间，也就是说要建立多少个结点。当然用结构数组也可以完成上述工作，但如果预先不能准确把握学生人数，也就无法确定数组大小。而且当学生留级、退学之后也不能把该元素占用的空间从数组中释放出来。\n用动态存储的方法可以很好地解决这些问题。有一个学生就分配一个结点，无须预先确定学生的准确人数，某学生退学，可删去该结点，并释放该结点占用的存储空间。从而节约了宝贵的内存资源。另一方面，用数组的方法必须占用一块连续的内存区域。而使用动态分配时，每个结点之间可以是不连续的(结点内是连续的)。结点之间的联系可以用指针实现。 即在结点结构中定义一个成员项用来存放下一结点的首地址，这个用于存放地址的成员，常把它称为指针域。\n可在第一个结点的指针域内存入第二个结点的首地址，在第二个结点的指针域内又存放第三个结点的首地址，如此串连下去直到最后一个结点。最后一个结点因无后续结点连接，其指针域可赋为0。这样一种连接方式，在数据结构中称为“链表”。\n下图为最一简单链表的示意图。\n\n图中，第0个结点称为头结点，它存放有第一个结点的首地址，它没有数据，只是一个指针变量。以下的每个结点都分为两个域，一个是数据域，存放各种实际的数据，如学号num，姓名name，性别sex和成绩score等。另一个域为指针域，存放下一结点的首地址。链表中的每一个结点都是同一种结构类型。\n例如，一个存放学生学号和成绩的结点应为以下结构：\nstruct stu\n{ int num;\nint score;\nstruct stu *next;\n}\n前两个成员项组成数据域，后一个成员项next构成指针域，它是一个指向stu类型结构的指针变量。\n链表的基本操作对链表的主要操作有以下几种：\n1. 建立链表；\n2. 结构的查找与输出；\n3. 插入一个结点；\n4. 删除一个结点；\n下面通过例题来说明这些操作。\n【例11.9】建立一个三个结点的链表，存放学生数据。为简单起见， 我们假定学生数据结构中只有学号和年龄两项。可编写一个建立链表的函数creat。程序如下：\n#define NULL 0\n#define TYPE struct stu\n#define LEN sizeof (struct stu)\nstruct stu\n{\nint num;\nint age;\nstruct stu *next;\n};\nTYPE *creat(int n)\n{\nstruct stu *head,*pf,*pb;\nint i;\nfor(i=0;i<n;i++)\n{\npb=(TYPE*) malloc(LEN);\nprintf(\"input Number and Age\\n\");\nscanf(\"%d%d\",&pb->num,&pb->age);\nif(i==0)\npf=head=pb;\nelse pf->next=pb;\npb->next=NULL;\npf=pb;\n}\nreturn(head);\n}\n在函数外首先用宏定义对三个符号常量作了定义。这里用 TYPE表示struct stu，用LEN表示sizeof(struct stu)主要的目的是为了在以下程序内减少书写并使阅读更加方便。结构stu定义为外部类型，程序中的各个函数均可使用该定义。\ncreat函数用于建立一个有n个结点的链表，它是一个指针函数，它返回的指针指向stu结构。在creat函数内定义了三个stu结构的指针变量。head为头指针，pf为指向两相邻结点的前一结点的指针变量。pb为后一结点的指针变量。\n11.10 枚举类型\n在实际问题中，有些变量的取值被限定在一个有限的范围内。例如，一个星期内只有七天，一年只有十二个月，一个班每周有六门课程等等。如果把这些量说明为整型，字符型或其它类型显然是不妥当的。为此，C语言提供了一种称为“枚举”的类型。在“枚举”类型的定义中列举出所有可能的取值，被说明为该“枚举”类型的变量取值不能超过定义的范围。应该说明的是，枚举类型是一种基本数据类型，而不是一种构造类型，因为它不能再分解为任何基本类型。\n11.10.1 枚举类型的定义和枚举变量的说明\n1. 枚举的定义枚举类型定义的一般形式为：\nenum 枚举名{ 枚举值表 };\n在枚举值表中应罗列出所有可用值。这些值也称为枚举元素。\n例如：\n\n该枚举名为weekday，枚举值共有7个，即一周中的七天。凡被说明为weekday类型变量的取值只能是七天中的某一天。\n2. 枚举变量的说明\n如同结构和联合一样，枚举变量也可用不同的方式说明，即先定义后说明，同时定义说明或直接说明。\n设有变量a,b,c被说明为上述的weekday，可采用下述任一种方式：\nenum weekday{ sun,mou,tue,wed,thu,fri,sat };\nenum weekday a,b,c;\n或者为：\nenum weekday{ sun,mou,tue,wed,thu,fri,sat }a,b,c;\n或者为：\nenum { sun,mou,tue,wed,thu,fri,sat }a,b,c;\n11.10.2 枚举类型变量的赋值和使用\n枚举类型在使用中有以下规定：\n1. 枚举值是常量，不是变量。不能在程序中用赋值语句再对它赋值。\n例如对枚举weekday的元素再作以下赋值：\nsun=5;\nmon=2;\nsun=mon;\n都是错误的。\n2. 枚举元素本身由系统定义了一个表示序号的数值，从0开始顺序定义为0，1，2…。如在weekday中，sun值为0，mon值为1，…,sat值为6。\n【例11.10】\nmain(){\nenum weekday\n{ sun,mon,tue,wed,thu,fri,sat } a,b,c;\na=sun;\nb=mon;\nc=tue;\nprintf(\"%d,%d,%d\",a,b,c);\n}\n\n说明：\n只能把枚举值赋予枚举变量，不能把元素的数值直接赋予枚举变量。如：\na=sum;\nb=mon;\n是正确的。而：\na=0;\nb=1;\n是错误的。如一定要把数值赋予枚举变量，则必须用强制类型转换。\n如：\na=(enum weekday)2;\n其意义是将顺序号为2的枚举元素赋予枚",
            "index": 46
        },
        {
            "content": "整型就是数字型，用于数学计算的，不可以输入字符型，字符型要定义char 或者string",
            "index": 47
        },
        {
            "content": "展开全部\n逻辑结构有四种基本类型：集合结构、线性结构、树状结构和网络结构。\n1、集合结构：集合结构的集合中任何两个数据元素之间都没有逻辑关系，组织形式松散。\n2、线性结构：线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构。\n3、树状结构：树状结构是一个或多个节点的有限集合。\n4、网络结构：网络结构是指通信系统的整体设计，它为网络硬件、软件、协议、存取控制和拓扑提供标准。\n扩展资料：\n线性结构中的结点按逻辑关系依次排列形成一个“锁链”。必存在唯一的一个\"第一个元素\"和唯一的一个\"最后的元素\"。除最后元素之外，其它数据元素均有唯一的\"后继\"；除第一元素之外，其它数据元素均有唯一的\"前驱\"。\n树形结构具有分支、层次特性，其形态有点象自然界中的树。网络结构广泛采用的是国际标准化组织（ISO）在1979年提出的开放系统互连（OSI-Open System Interconnection)的参考模型。",
            "index": 48
        },
        {
            "content": "展开全部\n排序方法：\n设一个中间变量\ntemp\nif(a>b)\n{\ntemp=a;\na=b;\nb=temp;\n}\nif(a>c)\n{\ntemp=a;\na=c;\nc=temp;\n}\nif(b>c)\n{\ntemp=b;\nb=c;\nc=temp;\n}\n你看代码的逻辑，流程图然清楚了次判断，如果第一个比第二个大，利用temp进行交换，保证第一个一直都是最小。三次比较后，自然a,b,c的顺序就是从小到大了",
            "index": 49
        }
    ]
}